import { Tokenizer } from './tokenizer.js';
import { Chunk, RecursiveRules } from './types.js';
/**
 * Configuration options for RecursiveChunker.
 */
export interface RecursiveChunkerOptions {
    /** Maximum number of tokens per chunk */
    chunkSize?: number;
    /** Rules defining the recursive chunking hierarchy */
    rules?: RecursiveRules;
    /** Tokenizer instance or model name (default: 'character') */
    tokenizer?: Tokenizer | string;
    /** Minimum number of characters per chunk when merging */
    minCharactersPerChunk?: number;
}
/**
 * Recursively chunks text using a hierarchical set of rules.
 *
 * The chunker splits text at progressively finer granularities:
 * paragraphs → sentences → punctuation → words → characters
 *
 * Each chunk respects the configured chunk size limit.
 */
export declare class RecursiveChunker {
    readonly chunkSize: number;
    readonly rules: RecursiveRules;
    readonly minCharactersPerChunk: number;
    private tokenizer;
    private readonly sep;
    private readonly CHARS_PER_TOKEN;
    private constructor();
    /**
     * Create a RecursiveChunker instance.
     *
     * @param options - Configuration options
     * @returns Promise resolving to RecursiveChunker instance
     *
     * @example
     * // Character-based (no dependencies)
     * const chunker = await RecursiveChunker.create({ chunkSize: 512 });
     *
     * @example
     * // With HuggingFace tokenizer (requires @chonkiejs/token)
     * const chunker = await RecursiveChunker.create({
     *   tokenizer: 'gpt2',
     *   chunkSize: 512
     * });
     */
    static create(options?: RecursiveChunkerOptions): Promise<RecursiveChunker>;
    /**
     * Chunk a single text into an array of chunks.
     *
     * @param text - The text to chunk
     * @returns Array of chunks
     */
    chunk(text: string): Promise<Chunk[]>;
    /**
     * Estimate token count for a piece of text.
     * Uses a heuristic for quick estimation, falls back to actual counting.
     */
    private estimateTokenCount;
    /**
     * Split text according to a recursive level's rules.
     */
    private splitText;
    /**
     * Create a chunk with proper metadata.
     */
    private makeChunk;
    /**
     * Merge splits to respect chunk size limits.
     */
    private mergeSplits;
    /**
     * Binary search helper for merging splits.
     */
    private bisectLeft;
    /**
     * Core recursive chunking logic.
     */
    private recursiveChunk;
    toString(): string;
}
//# sourceMappingURL=recursive.d.ts.map