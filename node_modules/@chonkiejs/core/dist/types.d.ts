/**
 * Base chunk type representing a piece of text with metadata.
 */
export declare class Chunk {
    /** The text content of the chunk */
    text: string;
    /** The starting index of the chunk in the original text */
    startIndex: number;
    /** The ending index of the chunk in the original text */
    endIndex: number;
    /** The number of tokens in the chunk */
    tokenCount: number;
    /** Optional embedding vector for the chunk */
    embedding?: number[];
    constructor(data: {
        text: string;
        startIndex: number;
        endIndex: number;
        tokenCount: number;
        embedding?: number[];
    });
    /**
     * Get a string representation of the chunk.
     */
    toString(): string;
}
/**
 * Type for specifying where delimiters should be included in chunks.
 */
export type IncludeDelim = 'prev' | 'next' | 'none';
/**
 * Configuration for a single level in the recursive chunking hierarchy.
 */
export interface RecursiveLevelConfig {
    /** Delimiters to split on at this level */
    delimiters?: string | string[];
    /** Whether to use whitespace as the delimiter */
    whitespace?: boolean;
    /** Where to include the delimiter in the resulting chunks */
    includeDelim?: IncludeDelim;
}
/**
 * Represents one level in the recursive chunking hierarchy.
 */
export declare class RecursiveLevel {
    delimiters?: string | string[];
    whitespace: boolean;
    includeDelim: IncludeDelim;
    constructor(config?: RecursiveLevelConfig);
    private validate;
    toString(): string;
}
/**
 * Configuration for recursive chunking rules.
 */
export interface RecursiveRulesConfig {
    /** Array of levels to use for recursive chunking */
    levels?: RecursiveLevelConfig[];
}
/**
 * Defines the hierarchy of rules for recursive text chunking.
 *
 * Default hierarchy:
 * 1. Paragraphs (split on \n\n, \r\n, \n, \r)
 * 2. Sentences (split on . ! ?)
 * 3. Pauses (split on punctuation/symbols)
 * 4. Words (split on whitespace)
 * 5. Characters (token-level splitting)
 */
export declare class RecursiveRules {
    levels: RecursiveLevel[];
    constructor(config?: RecursiveRulesConfig);
    get length(): number;
    getLevel(index: number): RecursiveLevel | undefined;
    toString(): string;
}
//# sourceMappingURL=types.d.ts.map