/**
 * Base chunk type representing a piece of text with metadata.
 */
export class Chunk {
    constructor(data) {
        this.text = data.text;
        this.startIndex = data.startIndex;
        this.endIndex = data.endIndex;
        this.tokenCount = data.tokenCount;
        this.embedding = data.embedding;
        if (this.startIndex > this.endIndex) {
            throw new Error('Start index must be less than or equal to end index');
        }
        if (this.tokenCount < 0) {
            throw new Error('Token count must be non-negative');
        }
    }
    /**
     * Get a string representation of the chunk.
     */
    toString() {
        return this.text;
    }
}
/**
 * Represents one level in the recursive chunking hierarchy.
 */
export class RecursiveLevel {
    constructor(config = {}) {
        this.delimiters = config.delimiters;
        this.whitespace = config.whitespace ?? false;
        this.includeDelim = config.includeDelim ?? 'prev';
        this.validate();
    }
    validate() {
        if (this.delimiters !== undefined && this.whitespace) {
            throw new Error('Cannot use both custom delimiters and whitespace');
        }
        if (this.delimiters !== undefined) {
            if (typeof this.delimiters === 'string' && this.delimiters.length === 0) {
                throw new Error('Delimiter cannot be empty string');
            }
            if (Array.isArray(this.delimiters)) {
                if (this.delimiters.some(d => typeof d !== 'string' || d.length === 0)) {
                    throw new Error('Delimiter cannot be empty string');
                }
                if (this.delimiters.includes(' ')) {
                    throw new Error('Use whitespace option instead of space delimiter');
                }
            }
        }
    }
    toString() {
        return `RecursiveLevel(delimiters=${JSON.stringify(this.delimiters)}, whitespace=${this.whitespace}, includeDelim=${this.includeDelim})`;
    }
}
/**
 * Defines the hierarchy of rules for recursive text chunking.
 *
 * Default hierarchy:
 * 1. Paragraphs (split on \n\n, \r\n, \n, \r)
 * 2. Sentences (split on . ! ?)
 * 3. Pauses (split on punctuation/symbols)
 * 4. Words (split on whitespace)
 * 5. Characters (token-level splitting)
 */
export class RecursiveRules {
    constructor(config = {}) {
        if (config.levels === undefined) {
            // Default hierarchy
            this.levels = [
                new RecursiveLevel({ delimiters: ['\n\n', '\r\n', '\n', '\r'] }), // Paragraphs
                new RecursiveLevel({ delimiters: ['. ', '! ', '? '] }), // Sentences
                new RecursiveLevel({
                    delimiters: [
                        '{', '}', '"', '[', ']', '<', '>', '(', ')', ':', ';', ',',
                        'â€”', '|', '~', '-', '...', '`', "'"
                    ]
                }), // Pauses
                new RecursiveLevel({ whitespace: true }), // Words
                new RecursiveLevel() // Characters/tokens
            ];
        }
        else {
            this.levels = config.levels.map(levelConfig => new RecursiveLevel(levelConfig));
        }
    }
    get length() {
        return this.levels.length;
    }
    getLevel(index) {
        return this.levels[index];
    }
    toString() {
        return `RecursiveRules(${this.levels.length} levels)`;
    }
}
//# sourceMappingURL=types.js.map